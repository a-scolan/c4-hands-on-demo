model {
  customer = Actor_Person 'Client' {
    description 'Vault service user'
  }

  // --- TARGET SYSTEM ---
  vault = System_Existing 'Secure Vault System' {
    description 'Microservices-based secure file vault with async processing and distributed storage'
    
    // 0. Frontend
    frontend = Container_Spa 'Web UI' {
      technology 'React SPA'
      description 'Single Page Application'
      icon tech:react
    }

    // 1. Entry Point
    api = Container 'API Gateway' {
      technology 'Kong / API Gateway'
      description 'Routes requests and validates auth'
      icon tech:kong-icon

      router = Component 'Router' {
        technology 'Express Router'
        description 'Routes incoming requests to appropriate microservices'
      }

      auth = Component 'Auth Middleware' {
        technology 'JWT'
        description 'Validates JWT tokens and authorizes requests'
      }
    }

    // 2. Upload Service
    uploadService = Container_ApplicationServer 'Upload Service' {
      technology 'Node.js / Express'
      description 'Handles file uploads and validation'
      icon tech:nodejs-icon

      uploadHandler = Component 'Upload Handler' {
        technology 'Multer / Express'
        description 'Receives and validates files'
      }

      fileValidator = Component 'File Validator' {
        technology 'File Analysis'
        description 'Validates file type, size, and structure before queuing'
      }
    }

    // 3. Retrieval Service (merged Document + Download)
    retrievalService = Container_ApplicationServer 'Retrieval Service' {
      technology 'GoLang'
      description 'Document metadata management and file retrieval with caching'
      icon tech:go

      retrievalHandler = Component 'Retrieval Handler' {
        technology 'HTTP Handler'
        description 'Handles metadata queries and file retrieval requests'
      }

      cacheManager = Component 'Cache Manager' {
        technology 'Redis Client'
        description 'Caches frequently accessed metadata and encryption keys'
      }

      decryptor = Component 'Decryption Service' {
        technology 'AES-256'
        description 'Decrypts files for download'
      }
    }

    // 5. Async Buffer
    jobs = Container_Queue 'Processing Queue' {
	  #Queue
      technology 'RabbitMQ'
      description 'Async job queue for file processing tasks (scan, encrypt, store)'
      icon tech:rabbitmq-icon
    }

    // 6. Processing Worker
    worker = Container_ProcessingServer 'Processing Worker' {
      technology 'GoLang'
      description 'Async file processing (scanning, encryption, storage)'
      icon tech:go

      consumer = Component 'Queue Consumer' {
        technology 'RabbitMQ Client'
        description 'Receives jobs from queue'
      }

      orchestrator = Component 'Job Orchestrator' {
        technology 'Workflow Engine'
        description 'Coordinates processing steps and error handling'
      }

      scannerClient = Component 'Virus Scanner Client' {
        technology 'VirusTotal SDK'
        description 'Anti-virus scanning integration'
      }

      encryptor = Component 'Encryption Service' {
        technology 'AES-256 GCM'
        description 'Encrypts files before storage'
      }

      minioClient = Component 'MinIO Client' {
        technology 'S3-compatible SDK'
        description 'Handles encrypted file storage to MinIO (not AWS S3)'
      }

      metadataWriter = Component 'Metadata Writer' {
        technology 'MongoDB Driver'
        description 'Persists document metadata'
      }

      errorHandler = Component 'Error Handler' {
        technology 'Dead Letter Queue'
        description 'Manages failed jobs and retries'
      }
    }

    // 7. Persistence
    docDB = Container_Database 'Document DB' {
      technology 'MongoDB'
      icon tech:mongodb-icon
    }
  }

  // --- INTERNAL STORAGE ---
  minio = System_Existing 'MinIO Object Storage' {
    description 'Primary encrypted object storage (on-premises) with 3-node replication'
  }

  // --- EXTERNAL DEPENDENCIES (Cloud / SaaS) ---
  scanner = System_External 'VirusTotal API' {
    description 'SaaS Antivirus'
  }

  // --- REFACTORED RELATIONSHIPS ---
  
  // Client Access
  customer -[calls]-> frontend 'Access web interface'
  frontend -[calls]-> api 'All requests'

  // API Gateway Internal
  vault.api.router -[uses]-> vault.api.auth 'Authenticate requests'

  // Upload Flow - Validation BEFORE queuing (fail-fast)
  vault.api.router -[calls]-> uploadService 'Route upload requests'
  vault.uploadService.uploadHandler -[uses]-> vault.uploadService.fileValidator 'Validate file'
  vault.uploadService.fileValidator -[async]-> jobs 'Queue validated file for processing'

  // Worker Processing (Event-Driven - NO API calls TO worker)
  vault.worker.consumer -[async]-> jobs 'Consume upload jobs'
  vault.worker.consumer -[uses]-> vault.worker.orchestrator 'Delegate job'
  
  // Orchestrated Processing Pipeline (validation already done)
  vault.worker.orchestrator -[uses]-> vault.worker.scannerClient 'Scan for viruses'
  vault.worker.scannerClient -[calls]-> scanner 'Anti-virus check'
  vault.worker.orchestrator -[uses]-> vault.worker.encryptor 'Encrypt clean file'
  vault.worker.encryptor -[writes]-> docDB 'Store encryption key'
  vault.worker.orchestrator -[uses]-> vault.worker.minioClient 'Store file'
  vault.worker.minioClient -[writes]-> minio 'Save encrypted file (primary)'
  vault.worker.orchestrator -[uses]-> vault.worker.metadataWriter 'Update status'
  vault.worker.metadataWriter -[writes]-> docDB 'Save metadata as READY'
  
  // Error Handling
  vault.worker.orchestrator -[uses]-> vault.worker.errorHandler 'On failure'
  vault.worker.errorHandler -[writes]-> docDB 'Mark as FAILED'

  // Retrieval Flow - Unified service with caching
  vault.api.router -[calls]-> retrievalService 'Route list/download requests'
  vault.retrievalService.retrievalHandler -[uses]-> vault.retrievalService.cacheManager 'Check cache'
  vault.retrievalService.cacheManager -[reads]-> docDB 'Cache miss: fetch metadata'
  vault.retrievalService.retrievalHandler -[reads]-> minio 'Fetch encrypted file (primary)'
  vault.retrievalService.retrievalHandler -[uses]-> vault.retrievalService.decryptor 'Decrypt file'
  vault.retrievalService.decryptor -[uses]-> vault.retrievalService.cacheManager 'Retrieve encryption key'
}
